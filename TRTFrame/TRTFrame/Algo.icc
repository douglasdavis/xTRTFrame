// inline definitions

template <class T>
inline void xTRT::Algo::create(const T obj) {
  auto clone = obj.Clone();
  wk()->addOutput(clone);
  m_objStore.emplace(std::make_pair(clone->GetName(),clone));
}

template <class T>
inline T* xTRT::Algo::grab(const std::string& name) {
  auto iter = m_objStore.find(name);
  if ( iter == m_objStore.end() ) {
    ANA_MSG_FATAL("Cannot find object with name:" << name);
  }
  return dynamic_cast<T*>(iter->second);
}

inline void xTRT::Algo::setTreeOutputName(const std::string name) {
  m_outputName = name;
}

inline void xTRT::Algo::feedConfig(const std::string fileName, bool print_conf) {
  m_config.parse(fileName, print_conf);
}

inline const xTRT::Config* xTRT::Algo::config() const {
  return &m_config;
}

inline xAOD::TEvent* xTRT::Algo::event() {
  return m_event;
}

inline xAOD::TStore* xTRT::Algo::store() {
  return m_store;
}

inline const xAOD::EventInfo* xTRT::Algo::eventInfo() {
  const xAOD::EventInfo* evtinfo = nullptr;
  if ( evtStore()->retrieve(evtinfo,"EventInfo").isFailure() ) {
    ANA_MSG_ERROR("Cannot retrieve EventInfo for some reason");
  }
  return evtinfo;
}

template <class T1, class T2>
inline T1 xTRT::Algo::get(const SG::AuxElement::ConstAccessor<T1>& acc, const T2* xobj, std::string adn) const {
  if ( acc.isAvailable(*xobj) ) {
    return acc(*xobj);
  }
  ANA_MSG_WARNING("AuxElement: " << adn << " is not available! Returning 0!");
  return 0;
}

template <class T1, class T2>
inline T1 xTRT::Algo::retrieve(const T2* xobj, const char* adn) const {
  static const SG::AuxElement::ConstAccessor<T1> acc{adn};
  if ( acc.isAvailable(*xobj) ) {
    return acc(*xobj);
  }
  else {
    ANA_MSG_WARNING("Cannot find " << adn);
    return 0;
  }
}

template <class C, class T>
inline const C* xTRT::Algo::selectedContainer(const C* raw,
                                              std::function<bool(const T*,const xTRT::Config*)> selector,
                                              const std::string& contName) {
  auto goodObjects    = std::make_unique<C>();
  auto goodObjectsAux = std::make_unique<xAOD::AuxContainerBase>();
  goodObjects->setStore(goodObjectsAux.get());
  for ( auto obj : *raw ) {
    if ( selector(obj,config()) ) {
      auto goodObj = new T();
      goodObjects->push_back(goodObj);
      *goodObj = *obj;
    }
  }
  if ( evtStore()->record(goodObjects.release(),contName).isFailure() ) {
    ANA_MSG_ERROR("Couldn't record " << contName << ", returning nullptr.");
    return nullptr;
  }
  if ( evtStore()->record(goodObjectsAux.release(),contName+"Aux.").isFailure() ) {
    ANA_MSG_ERROR("Couldn't record " << contName << "Aux., returning nullptr.");
    return nullptr;
  }
  const C* retObjs = nullptr;
  if ( evtStore()->retrieve(retObjs,contName).isFailure() ) {
    ANA_MSG_ERROR("Couldn't retrieve " << contName << ", returning nullptr");
    return nullptr;
  }
  return retObjs;
}
